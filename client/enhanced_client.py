#!/usr/bin/env python3
"""
Luxembourg Legal Research Client - Enhanced Edition
Showcases professional legal research capabilities using the enhanced MCP server.
"""

import os
import json
import asyncio
from typing import Dict, List, Any, Optional
import anthropic
from dotenv import load_dotenv
import logging
import time
from fastmcp import Client
from fastmcp.client.transports import StreamableHttpTransport

load_dotenv()
logger = logging.getLogger(__name__)


class EnhancedLegalClient:
    """Enhanced client showcasing professional Luxembourg legal research capabilities."""
    
    def __init__(self):
        self.api_key = os.getenv("ANTHROPIC_API_KEY")
        if not self.api_key:
            raise ValueError("ANTHROPIC_API_KEY not found in environment variables")
        
        self.model = "claude-3-5-sonnet-20241022"  # Use Sonnet for better analysis
        self.mcp_server_url = os.getenv("MCP_SERVER_URL", "http://localhost:8080")
        
        # Initialize Anthropic client
        self.client = anthropic.AsyncAnthropic(api_key=self.api_key)
        
        # Enhanced system prompt for professional legal research
        self.system_prompt = """Vous √™tes un assistant juridique expert en droit luxembourgeois avec acc√®s √† un syst√®me avanc√© de recherche l√©gale.

üéØ SYST√àME ENHANCED MCP - CAPACIT√âS PROFESSIONNELLES:

Vous disposez de 18 outils avanc√©s pour la recherche l√©gale professionnelle:

== OUTILS DE BASE ==

1. üèõÔ∏è identify_legal_domain
   ‚Üí Identifie le domaine juridique avec m√©tadonn√©es enrichies
   ‚Üí Retourne: domaine, mots-cl√©s, types de documents, autorit√©s comp√©tentes

2. üîç smart_legal_search  
   ‚Üí Recherche avec mots-cl√©s juridiques PR√âCIS (√©viter termes g√©n√©raux)
   ‚Üí Choisir des termes juridiques sp√©cifiques selon le contexte l√©gal
   ‚Üí Exploite les relations JOLUX + score de pertinence JOLUX-optimis√©

3. üîç multi_field_legal_search  
   ‚Üí Recherche multi-champs simultan√©e (titre + relations + autorit√©)
   ‚Üí Version optimis√©e pour mots-cl√©s simples
   ‚Üí Trouve 50-500 documents avec m√©tadonn√©es compl√®tes

4. üîó discover_legal_relationships
   ‚Üí D√©couvre les cha√Ænes d'amendements et relations juridiques
   ‚Üí Suit les relations transitives (jolux:basedOn+)
   ‚Üí Identifie: fondation l√©gale, impl√©mentations, amendements

4. üìÖ temporal_legal_analysis
   ‚Üí Analyse temporelle multi-dates pour validation de la validit√© l√©gale
   ‚Üí Utilise: dateDocument, publicationDate, dateEntryInForce
   ‚Üí √âvalue: documents actuels vs. historiques

5. ‚öñÔ∏è assess_legal_authority
   ‚Üí Classement par hi√©rarchie l√©gale luxembourgeoise
   ‚Üí BaseAct > Act > Memorial > LegalResource > NationalLegalResource
   ‚Üí Int√®gre: autorit√© de publication + anciennet√©

6. üìÑ extract_document_content
   ‚Üí Extraction de contenu r√©el (HTML/PDF luxembourgeois)
   ‚Üí Analyse structure l√©gale (articles, chapitres, sections)
   ‚Üí Concepts juridiques d√©tect√©s automatiquement

== NOUVEAUX OUTILS D'INTELLIGENCE JURIDIQUE ==

7. üîó analyze_citation_network
   ‚Üí Analyse compl√®te du r√©seau de citations (75K+ relations)
   ‚Üí D√©couvre les pr√©c√©dents juridiques et r√©f√©rences crois√©es
   ‚Üí Profondeur d'analyse configurable (1-2 niveaux)

8. üìö find_citing_documents
   ‚Üí Trouve les documents qui citent une loi sp√©cifique
   ‚Üí Utilise jolux:cites (75,123 relations de citation)
   ‚Üí Identifie l'influence juridique d'un texte

9. üìñ find_cited_documents
   ‚Üí Trouve les documents cit√©s par une loi sp√©cifique
   ‚Üí D√©couvre les fondements juridiques et autorit√©s
   ‚Üí Trace les sources l√©gales

10. üìù analyze_amendment_chain
    ‚Üí Analyse compl√®te de l'historique d'amendements
    ‚Üí Utilise jolux:modifies/modifiedBy (26K+ modifications)
    ‚Üí Timeline chronologique des modifications

11. üïê find_latest_amendments
    ‚Üí Trouve les amendements les plus r√©cents
    ‚Üí Validation de la version actuelle d'une loi
    ‚Üí Suivi des changements l√©gislatifs

12. üí∞ check_legal_currency
    ‚Üí V√©rifie si un document est encore juridiquement valide
    ‚Üí Utilise jolux:repeals (17,910 relations d'abrogation)
    ‚Üí Statut: CURRENT ou REPEALED avec d√©tails

13. üîÑ analyze_replacement_chain
    ‚Üí Analyse les cha√Ænes de remplacement/abrogation
    ‚Üí Que cette loi abroge vs. ce qui l'abroge
    ‚Üí Position dans la cha√Æne de remplacement

14. üìã find_consolidated_versions
    ‚Üí Trouve les versions consolid√©es officielles
    ‚Üí Utilise jolux:consolidates (368 consolidations)
    ‚Üí Textes officiels √† jour

15. üåç find_multilingual_versions
    ‚Üí Trouve les versions dans diff√©rentes langues
    ‚Üí Utilise jolux:language (238K+ versions linguistiques)
    ‚Üí Support fran√ßais, allemand, anglais

16. ‚ö° get_current_effective_version
    ‚Üí D√©termine la version effective actuelle recommand√©e
    ‚Üí Combine consolidation + multilingue + validit√©
    ‚Üí Recommandation pour la pratique juridique

17. üìã get_enhanced_workflow_guidance
    ‚Üí Guide des workflows professionnels optimaux
    ‚Üí 3 workflows sp√©cialis√©s disponibles

üîÑ WORKFLOWS PROFESSIONNELS DISPONIBLES:

== WORKFLOW 1: RECHERCHE L√âGALE COMPL√àTE ==
1. identify_legal_domain ‚Üí domaine + guidance
2. smart_legal_search ‚Üí d√©couverte intelligente multi-mots
3. discover_legal_relationships ‚Üí relations de base
4. analyze_citation_network ‚Üí r√©seau de pr√©c√©dents 
5. analyze_amendment_chain ‚Üí historique des modifications
6. check_legal_currency ‚Üí validation de validit√©
7. find_consolidated_versions ‚Üí versions officielles
8. extract_document_content ‚Üí contenu l√©gal r√©el

== WORKFLOW 2: INTELLIGENCE RELATIONNELLE ==
1. smart_legal_search ‚Üí documents de base
2. analyze_citation_network ‚Üí r√©seau de citations complet
3. find_citing_documents ‚Üí qui r√©f√©rence ces lois
4. find_cited_documents ‚Üí fondements juridiques
5. analyze_amendment_chain ‚Üí √©volution l√©gislative
6. analyze_replacement_chain ‚Üí cha√Ænes d'abrogation

== WORKFLOW 3: VALIDIT√â ET VERSIONS ==
1. smart_legal_search ‚Üí documents pertinents
2. check_legal_currency ‚Üí validation de validit√©
3. find_latest_amendments ‚Üí modifications r√©centes
4. find_consolidated_versions ‚Üí versions consolid√©es
5. find_multilingual_versions ‚Üí versions linguistiques
6. get_current_effective_version ‚Üí recommandation finale

üí° NOUVELLES CAPACIT√âS D'INTELLIGENCE JURIDIQUE:

- R√âSEAU DE CITATIONS: 75,123 relations de citation analysables
- CHA√éNES D'AMENDEMENTS: 26,826 modifications + 578 liens inverses
- VALIDATION DE VALIDIT√â: 17,910 relations d'abrogation
- VERSIONS CONSOLID√âES: 368 consolidations officielles  
- SUPPORT MULTILINGUE: 238,518 versions linguistiques
- ANALYSE RELATIONNELLE: R√©seaux de pr√©c√©dents juridiques
- VALIDIT√â JURIDIQUE: V√©rification automatique du statut l√©gal
- VERSIONS EFFECTIVES: Recommandations pour la pratique

‚öñÔ∏è STANDARDS JURIDIQUES PROFESSIONNELS:

- Hi√©rarchie l√©gale: Actes de base > Lois > R√®glements > D√©cisions administratives
- Autorit√©: Parlement > Minist√®re > Administration
- Validit√©: Documents actuels > non-abrog√©s > versions consolid√©es
- Sources: Documents officiels avec URIs l√©gaux complets + validation de validit√©
- R√©seau: Citations bidirectionnelles + cha√Ænes d'amendements compl√®tes

üéØ EXEMPLES D'UTILISATION OPTIMALE:

== STRAT√âGIE DE RECHERCHE JURIDIQUE ==
- identify_legal_domain ‚Üí Analyse la question et extrait les termes juridiques
- Choisir des mots-cl√©s PR√âCIS selon le domaine juridique identifi√©
- √âVITER: termes g√©n√©raux comme "cr√©ation", "obligations", "proc√©dures"
- PRIVIL√âGIER: termes juridiques sp√©cifiques selon le contexte (entit√©s l√©gales, concepts pr√©cis)
- analyze_citation_network ‚Üí R√©seau de lois SARL interconnect√©es
- analyze_amendment_chain ‚Üí √âvolution du droit SARL 2016-2025
- check_legal_currency ‚Üí Confirmation validit√© actuelle
- find_consolidated_versions ‚Üí Texte SARL consolid√© officiel
- extract_document_content ‚Üí Articles 175-218 + proc√©dures actuelles

== Pour analyse de pr√©c√©dents juridiques ==
- smart_legal_search ‚Üí Documents de jurisprudence
- find_citing_documents ‚Üí Qui cite cette d√©cision
- analyze_citation_network ‚Üí R√©seau de pr√©c√©dents (2 niveaux)
- find_cited_documents ‚Üí Autorit√©s juridiques invoqu√©es

R√âPONDEZ TOUJOURS EN FRAN√áAIS avec une analyse juridique professionnelle compl√®te."""

        self.available_tools = []
        self._tools_initialized = False
        
        # Cost tracking
        self.total_input_tokens = 0
        self.total_output_tokens = 0
        self.query_count = 0
    
    async def initialize_tools(self):
        """Initialize enhanced MCP tools."""
        if self._tools_initialized:
            return
        
        logger.info("üîß Initializing Enhanced MCP Tools...")
        try:
            # Always use HTTP transport for real MCP server connection
            transport = StreamableHttpTransport(url=self.mcp_server_url)
            async with Client(transport) as client:
                tools = await client.list_tools()
                
                # Convert MCP tools to Claude format
                self.available_tools = []
                for tool in tools:
                    claude_tool = {
                        "name": tool.name,
                        "description": tool.description,
                        "input_schema": tool.inputSchema
                    }
                    self.available_tools.append(claude_tool)
            
            self._tools_initialized = True
            logger.info(f"‚úÖ Initialized {len(self.available_tools)} enhanced tools")
            
            # Display available tools
            print("\nüîß ENHANCED MCP TOOLS AVAILABLE:")
            for tool in self.available_tools:
                print(f"   ‚Ä¢ {tool['name']}: {tool['description']}")
            print()
                
        except Exception as e:
            logger.error(f"‚ùå Failed to initialize MCP tools: {e}")
            self.available_tools = []
    
    async def call_mcp_tool(self, tool_name: str, tool_input: Dict[str, Any]) -> Dict[str, Any]:
        """Call MCP tool and return result."""
        try:
            # Always use HTTP transport for real MCP server connection
            transport = StreamableHttpTransport(url=self.mcp_server_url)
            async with Client(transport) as client:
                result = await client.call_tool(tool_name, tool_input)
                
                return {
                    "success": True,
                    "result": result,
                    "tool_name": tool_name,
                    "tool_input": tool_input
                }
                
        except Exception as e:
            logger.error(f"‚ùå MCP tool call failed: {e}")
            return {
                "success": False,
                "error": str(e),
                "tool_name": tool_name,
                "tool_input": tool_input
            }
    
    def format_tool_result(self, tool_result: Dict[str, Any]) -> str:
        """Format tool execution result for Claude with enhanced display."""
        if not tool_result["success"]:
            return f"‚ùå Erreur lors de l'ex√©cution de l'outil {tool_result['tool_name']}: {tool_result['error']}"
        
        result = tool_result["result"]
        tool_name = tool_result["tool_name"]
        
        # Enhanced formatting for each tool type
        if tool_name == "smart_legal_search":
            if isinstance(result, dict):
                doc_count = result.get("total_found", 0)
                keywords_used = result.get("keywords_used", [])
                keywords_original = result.get("keywords_original", "")
                return f"üß† RECHERCHE INTELLIGENTE: {doc_count} documents trouv√©s\nMots-cl√©s extraits: {keywords_used}\nRecherche originale: '{keywords_original}'\n{json.dumps(result, ensure_ascii=False, indent=2)}"
        
        elif tool_name == "multi_field_legal_search":
            if isinstance(result, dict):
                doc_count = result.get("total_found", 0)
                search_method = result.get("search_method", "unknown")
                return f"üîç RECHERCHE MULTI-CHAMPS: {doc_count} documents trouv√©s via {search_method}\n{json.dumps(result, ensure_ascii=False, indent=2)}"
        
        elif tool_name == "discover_legal_relationships":
            if isinstance(result, dict):
                rel_count = result.get("total_relationships", 0)
                rel_types = result.get("relationship_types_found", [])
                return f"üîó RELATIONS JURIDIQUES: {rel_count} relations trouv√©es\nTypes: {', '.join(rel_types)}\n{json.dumps(result, ensure_ascii=False, indent=2)}"
        
        elif tool_name == "temporal_legal_analysis":
            if isinstance(result, dict) and "temporal_analysis" in result:
                analysis = result["temporal_analysis"]
                current = len(analysis.get("current_documents", []))
                recent = len(analysis.get("recent_documents", []))
                historical = len(analysis.get("historical_documents", []))
                return f"üìÖ ANALYSE TEMPORELLE: {current} actuels, {recent} r√©cents, {historical} historiques\n{json.dumps(result, ensure_ascii=False, indent=2)}"
        
        elif tool_name == "assess_legal_authority":
            if isinstance(result, dict):
                top_count = result.get("top_selected", 0)
                method = result.get("authority_analysis", {}).get("assessment_method", "unknown")
                return f"‚öñÔ∏è AUTORIT√â L√âGALE: {top_count} documents class√©s par {method}\n{json.dumps(result, ensure_ascii=False, indent=2)}"
        
        # NEW LEGAL INTELLIGENCE TOOLS FORMATTING
        elif tool_name == "analyze_citation_network":
            if isinstance(result, dict):
                total_network = result.get("total_network_size", 0)
                inbound = result.get("inbound_citations", {}).get("citation_count", 0)
                outbound = result.get("outbound_citations", {}).get("citation_count", 0)
                return f"üîó R√âSEAU DE CITATIONS: {total_network} connexions totales ({inbound} entrants, {outbound} sortants)\n{json.dumps(result, ensure_ascii=False, indent=2)}"
        
        elif tool_name == "find_citing_documents":
            if isinstance(result, dict):
                count = result.get("citation_count", 0)
                return f"üìö DOCUMENTS CITANTS: {count} documents citent ce texte\n{json.dumps(result, ensure_ascii=False, indent=2)}"
        
        elif tool_name == "find_cited_documents":
            if isinstance(result, dict):
                count = result.get("citation_count", 0)
                return f"üìñ DOCUMENTS CIT√âS: {count} documents cit√©s par ce texte\n{json.dumps(result, ensure_ascii=False, indent=2)}"
        
        elif tool_name == "analyze_amendment_chain":
            if isinstance(result, dict):
                total_mods = result.get("total_modifications", 0)
                total_docs_mod = result.get("total_documents_modified", 0)
                activity = result.get("amendment_activity_level", "unknown")
                return f"üìù CHA√éNE D'AMENDEMENTS: {total_mods} modifications re√ßues, {total_docs_mod} documents modifi√©s (activit√©: {activity})\n{json.dumps(result, ensure_ascii=False, indent=2)}"
        
        elif tool_name == "find_latest_amendments":
            if isinstance(result, dict):
                count = result.get("amendment_count", 0)
                return f"üïê AMENDEMENTS R√âCENTS: {count} amendements r√©cents trouv√©s\n{json.dumps(result, ensure_ascii=False, indent=2)}"
        
        elif tool_name == "check_legal_currency":
            if isinstance(result, dict):
                status = result.get("status", "unknown")
                is_current = result.get("is_legally_current", None)
                status_msg = result.get("status_message", "")
                return f"üí∞ VALIDIT√â L√âGALE: {status} - {status_msg}\n{json.dumps(result, ensure_ascii=False, indent=2)}"
        
        elif tool_name == "analyze_replacement_chain":
            if isinstance(result, dict):
                repeals_made = result.get("total_repeals_made", 0)
                repeals_received = result.get("total_repeals_received", 0)
                position = result.get("chain_position", "unknown")
                return f"üîÑ CHA√éNE DE REMPLACEMENT: {repeals_made} abrogations, {repeals_received} abrog√© par (position: {position})\n{json.dumps(result, ensure_ascii=False, indent=2)}"
        
        elif tool_name == "find_consolidated_versions":
            if isinstance(result, dict):
                count = result.get("consolidation_count", 0)
                return f"üìã VERSIONS CONSOLID√âES: {count} versions consolid√©es trouv√©es\n{json.dumps(result, ensure_ascii=False, indent=2)}"
        
        elif tool_name == "find_multilingual_versions":
            if isinstance(result, dict):
                lang_count = result.get("language_count", 0)
                languages = result.get("languages_available", [])
                return f"üåç VERSIONS MULTILINGUES: {lang_count} langues ({', '.join(languages[:3])}{'...' if len(languages) > 3 else ''})\n{json.dumps(result, ensure_ascii=False, indent=2)}"
        
        elif tool_name == "get_current_effective_version":
            if isinstance(result, dict):
                recommendation = result.get("recommendation_reason", "unknown")
                return f"‚ö° VERSION EFFECTIVE: {recommendation}\n{json.dumps(result, ensure_ascii=False, indent=2)}"
        
        # Default formatting
        if hasattr(result, 'text'):
            return result.text
        elif hasattr(result, 'content'):
            if isinstance(result.content, list):
                return "\n".join([
                    content.text if hasattr(content, 'text') 
                    else str(content) for content in result.content
                ])
            else:
                return str(result.content)
        elif isinstance(result, dict) and "content" in result:
            return result["content"]
        elif isinstance(result, str):
            return result
        else:
            try:
                return json.dumps(result, ensure_ascii=False, indent=2, default=str)
            except (TypeError, AttributeError):
                return str(result)
    
    async def chat(self, message: str, conversation_history: Optional[List[Dict]] = None) -> Dict[str, Any]:
        """Enhanced chat with professional legal research workflow."""
        start_time = time.time()
        self.query_count += 1
        
        await self.initialize_tools()
        
        # Build conversation
        messages = []
        if conversation_history:
            messages.extend(conversation_history)
        
        messages.append({
            "role": "user",
            "content": message
        })
        
        # Track tool usage with enhanced metadata
        tools_used = []
        tool_results = []
        workflow_stage = "initialization"
        max_iterations = 20  # Allow for complete legal intelligence workflow with new tools
        iteration = 0
        
        print(f"\nüß† D√âMARRAGE RECHERCHE L√âGALE PROFESSIONNELLE")
        print(f"üìù Question: {message}")
        print(f"üîß Outils disponibles: {len(self.available_tools)}")
        print("=" * 80)
        
        while iteration < max_iterations:
            iteration += 1
            
            try:
                # Prepare request for Claude
                request_params = {
                    "model": self.model,
                    "max_tokens": 4000,  # Increased for complex legal analysis
                    "temperature": 0.3,  # Lower for more precise legal analysis
                    "system": self.system_prompt,
                    "messages": messages
                }
                
                # Add tools if available
                if self.available_tools:
                    request_params["tools"] = self.available_tools
                
                # Call Claude
                response = await self.client.messages.create(**request_params)
                
                # Track token usage
                if hasattr(response, 'usage'):
                    self.total_input_tokens += response.usage.input_tokens
                    self.total_output_tokens += response.usage.output_tokens
                
                # Check if Claude wants to use tools
                if response.stop_reason == "tool_use":
                    # Extract tool calls
                    assistant_message = {
                        "role": "assistant",
                        "content": response.content
                    }
                    messages.append(assistant_message)
                    
                    # Execute tools with enhanced logging
                    tool_results_for_claude = []
                    
                    for content_block in response.content:
                        if content_block.type == "tool_use":
                            tool_name = content_block.name
                            tool_input = content_block.input
                            tool_use_id = content_block.id
                            
                            print(f"\nüîß EX√âCUTION OUTIL: {tool_name}")
                            print(f"üì• Param√®tres: {json.dumps(tool_input, ensure_ascii=False)}")
                            
                            # Update workflow stage
                            if tool_name == "identify_legal_domain":
                                workflow_stage = "domain_identification"
                            elif tool_name in ["smart_legal_search", "multi_field_legal_search"]:
                                workflow_stage = "comprehensive_search"
                            elif tool_name == "discover_legal_relationships":
                                workflow_stage = "relationship_analysis"
                            elif tool_name == "temporal_legal_analysis":
                                workflow_stage = "currency_validation"
                            elif tool_name == "assess_legal_authority":
                                workflow_stage = "authority_ranking"
                            elif tool_name == "extract_document_content":
                                workflow_stage = "content_extraction"
                            # NEW LEGAL INTELLIGENCE WORKFLOW STAGES
                            elif tool_name == "analyze_citation_network":
                                workflow_stage = "citation_network_analysis"
                            elif tool_name in ["find_citing_documents", "find_cited_documents"]:
                                workflow_stage = "citation_discovery"
                            elif tool_name in ["analyze_amendment_chain", "find_latest_amendments"]:
                                workflow_stage = "amendment_analysis"
                            elif tool_name in ["check_legal_currency", "analyze_replacement_chain"]:
                                workflow_stage = "legal_currency_validation"
                            elif tool_name in ["find_consolidated_versions", "find_multilingual_versions", "get_current_effective_version"]:
                                workflow_stage = "version_analysis"
                            elif tool_name == "get_enhanced_workflow_guidance":
                                workflow_stage = "workflow_guidance"
                            
                            # Execute tool via MCP
                            tool_result = await self.call_mcp_tool(tool_name, tool_input)
                            
                            tools_used.append({
                                "name": tool_name,
                                "stage": workflow_stage,
                                "iteration": iteration
                            })
                            tool_results.append(tool_result)
                            
                            # Format result for Claude
                            formatted_result = self.format_tool_result(tool_result)
                            
                            print(f"üì§ R√©sultat: {formatted_result[:200]}{'...' if len(formatted_result) > 200 else ''}")
                            
                            tool_results_for_claude.append({
                                "type": "tool_result",
                                "tool_use_id": tool_use_id,
                                "content": formatted_result
                            })
                    
                    # Add tool results to conversation
                    messages.append({
                        "role": "user",
                        "content": tool_results_for_claude
                    })
                    
                    # Continue conversation with tool results
                    continue
                
                else:
                    # Final response from Claude
                    final_response = ""
                    for content_block in response.content:
                        if content_block.type == "text":
                            final_response += content_block.text
                    
                    # Calculate costs
                    processing_time = time.time() - start_time
                    input_cost = (self.total_input_tokens / 1_000_000) * 3.0  # Sonnet pricing
                    output_cost = (self.total_output_tokens / 1_000_000) * 15.0
                    total_cost = input_cost + output_cost
                    
                    # Enhanced workflow summary
                    workflow_summary = {
                        "total_tools_used": len(tools_used),
                        "workflow_stages_completed": list(set([tool["stage"] for tool in tools_used])),
                        "research_depth": "professional" if len(tools_used) >= 4 else "basic",
                        "final_stage": workflow_stage
                    }
                    
                    print(f"\n‚úÖ RECHERCHE L√âGALE TERMIN√âE")
                    print(f"üîß Outils utilis√©s: {len(tools_used)}")
                    print(f"üéØ √âtapes: {', '.join(workflow_summary['workflow_stages_completed'])}")
                    print(f"‚öñÔ∏è Niveau: {workflow_summary['research_depth']}")
                    print(f"üí∞ Co√ªt estim√©: ${total_cost:.4f}")
                    print("=" * 80)
                    
                    return {
                        "response": final_response,
                        "tools_used": tools_used,
                        "tool_results": tool_results,
                        "workflow_summary": workflow_summary,
                        "conversation": messages,
                        "model_used": self.model,
                        "iterations": iteration,
                        "cost_info": {
                            "input_tokens": getattr(response.usage, 'input_tokens', 0) if hasattr(response, 'usage') else 0,
                            "output_tokens": getattr(response.usage, 'output_tokens', 0) if hasattr(response, 'usage') else 0,
                            "estimated_cost_usd": round(total_cost, 6),
                            "processing_time_ms": round(processing_time * 1000, 2)
                        },
                        "provider": "anthropic_api_enhanced"
                    }
            
            except Exception as e:
                logger.error(f"‚ùå Anthropic API error: {e}")
                return {
                    "response": f"Erreur de service Anthropic: {str(e)}",
                    "tools_used": tools_used,
                    "tool_results": tool_results,
                    "error": str(e),
                    "provider": "anthropic_api_enhanced"
                }
        
        # Max iterations reached
        return {
            "response": "Recherche l√©gale complexe interrompue (limite d'it√©rations atteinte).",
            "tools_used": tools_used,
            "tool_results": tool_results,
            "warning": "Max iterations reached",
            "provider": "anthropic_api_enhanced"
        }
    
    def display_enhanced_capabilities(self):
        """Display the enhanced system capabilities."""
        print("\nüöÄ SYST√àME DE RECHERCHE L√âGALE LUXEMBOURGEOISE - INTELLIGENCE JURIDIQUE")
        print("=" * 90)
        print("üìä CAPACIT√âS D'INTELLIGENCE JURIDIQUE PROFESSIONNELLE:")
        print("   ‚Ä¢ Recherche multi-champs simultan√©e (titre + relations + autorit√©)")
        print("   ‚Ä¢ Analyse de r√©seaux de citations (75,123 relations)")
        print("   ‚Ä¢ D√©couverte automatique de cha√Ænes d'amendements (26,826+ modifications)")
        print("   ‚Ä¢ Validation de validit√© l√©gale en temps r√©el (17,910 abrogations)")
        print("   ‚Ä¢ Versions consolid√©es officielles (368 consolidations)")
        print("   ‚Ä¢ Support multilingue complet (238,518 versions linguistiques)")
        print("   ‚Ä¢ Classement par hi√©rarchie juridique luxembourgeoise")
        print("   ‚Ä¢ Extraction de contenu r√©el HTML/PDF")
        print("   ‚Ä¢ Int√©gration du droit europ√©en (transposition)")
        print()
        print("‚öñÔ∏è NOUVELLES CAPACIT√âS D'INTELLIGENCE:")
        print("   ‚Ä¢ R√âSEAU DE CITATIONS: Pr√©c√©dents juridiques et r√©f√©rences crois√©es")
        print("   ‚Ä¢ CHA√éNES D'AMENDEMENTS: √âvolution l√©gislative compl√®te")
        print("   ‚Ä¢ VALIDIT√â JURIDIQUE: Statut l√©gal actuel automatique")
        print("   ‚Ä¢ VERSIONS EFFECTIVES: Recommandations pour la pratique")
        print("   ‚Ä¢ ANALYSE RELATIONNELLE: Interconnexions juridiques bidirectionnelles")
        print()
        print("‚öñÔ∏è STANDARDS JURIDIQUES RENFORC√âS:")
        print("   ‚Ä¢ BaseAct > Act > Memorial > Regulation > Administrative")
        print("   ‚Ä¢ Parlement > Minist√®re > Administration")
        print("   ‚Ä¢ Documents actuels > non-abrog√©s > versions consolid√©es")
        print("   ‚Ä¢ Validation automatique de validit√© l√©gale")
        print()
        print("üîç PERFORMANCE PROFESSIONNELLE:")
        print("   ‚Ä¢ 17 outils sp√©cialis√©s (vs. 6 auparavant)")
        print("   ‚Ä¢ 50-500 documents par recherche avec m√©tadonn√©es compl√®tes")
        print("   ‚Ä¢ Relations juridiques compl√®tes d√©couvertes automatiquement")
        print("   ‚Ä¢ Validit√© l√©gale confirm√©e en temps r√©el")
        print("   ‚Ä¢ R√©seaux de citations et pr√©c√©dents analys√©s")
        print("   ‚Ä¢ Versions consolid√©es et multilingues identifi√©es")
        print("   ‚Ä¢ 3 workflows professionnels sp√©cialis√©s")
        print("=" * 90)


# Test function for enhanced capabilities
async def test_enhanced_system():
    """Test the enhanced legal research system."""
    client = EnhancedLegalClient()
    
    # Display capabilities
    client.display_enhanced_capabilities()
    
    # Test with a complex legal question
    test_question = "Comment cr√©er une SARL au Luxembourg? Quelles sont les obligations l√©gales et proc√©dures actuelles? Analysez aussi l'√©volution l√©gislative et les versions consolid√©es."
    
    print(f"\nüß™ TEST DU SYST√àME D'INTELLIGENCE JURIDIQUE")
    print(f"üìù Question test: {test_question}")
    print(f"üéØ Test des nouvelles capacit√©s: citations, amendements, validit√©, consolidation")
    
    try:
        result = await client.chat(test_question)
        
        print(f"\nüìã R√âSULTATS DU TEST:")
        print(f"‚úÖ R√©ponse g√©n√©r√©e: {len(result['response'])} caract√®res")
        print(f"üîß Outils utilis√©s: {len(result.get('tools_used', []))}")
        print(f"üéØ √âtapes workflow: {result.get('workflow_summary', {}).get('workflow_stages_completed', [])}")
        print(f"üí∞ Co√ªt: ${result.get('cost_info', {}).get('estimated_cost_usd', 0):.4f}")
        
        # Display partial response
        response_preview = result['response'][:500] + "..." if len(result['response']) > 500 else result['response']
        print(f"\nüìÑ APER√áU DE LA R√âPONSE:")
        print(response_preview)
        
    except Exception as e:
        print(f"‚ùå Erreur lors du test: {e}")


if __name__ == "__main__":
    asyncio.run(test_enhanced_system())